/**
 * GOOGLE APPS SCRIPT CHO PIMA
 * Chuyên dụng cho file: giá nano pima
 * Sheet ID: 1f5w7uPmiqwbrqARpdPvBJeAOh1LPhhOnAwO4JFIkCn4
 * Sheet Name: gia_web_nano
 */

// ============= CẤU HÌNH CỐ ĐỊNH =============
const SPREADSHEET_ID = '1f5w7uPmiqwbrqARpdPvBJeAOh1LPhhOnAwO4JFIkCn4';
const SHEET_NAME = 'gia_web_nano';

function doGet(e) {
  const params = e.parameter;
  const action = params.action;
  
  if (action === 'read') {
    return readData();
  }
  
  return jsonResponse({success: false, message: 'Invalid GET action'});
}

function doPost(e) {
  let data;
  try {
    data = JSON.parse(e.postData.contents);
  } catch (err) {
    return jsonResponse({success: false, message: 'Invalid JSON'});
  }
  
  const action = data.action;
  
  if (action === 'upload') {
    return uploadFile(data);
  } else if (action === 'create') {
    return createData(data);
  } else if (action === 'update') {
    return updateData(data);
  } else if (action === 'delete') {
    // Để thống nhất với logic Duraflex, ta coi delete 'product' là chủ yếu
    return deleteData(data);
  }
  
  return jsonResponse({success: false, message: 'Invalid POST action'});
}

function readData() {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEET_NAME);
    if (!sheet) return jsonResponse({success: false, message: 'Sheet not found: ' + SHEET_NAME});
    
    const values = sheet.getDataRange().getValues();
    if (values.length < 1) return jsonResponse({success: true, data: []});
    
    const headers = values[0];
    const data = [];
    
    for (let i = 1; i < values.length; i++) {
        // Bỏ qua dòng trống
        if (!values[i].join('').trim()) continue;
        
        let obj = {};
        headers.forEach((header, index) => {
            if (header) {
                obj[header] = values[i][index];
            }
        });
        data.push(obj);
    }
    
    return jsonResponse({success: true, data: data});
  } catch (err) {
    return jsonResponse({success: false, message: err.toString()});
  }
}

function createData(payload) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEET_NAME);
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const newRow = headers.map(h => payload.data[h] !== undefined ? payload.data[h] : '');
    
    sheet.appendRow(newRow);
    return jsonResponse({success: true});
  } catch (err) {
    return jsonResponse({success: false, message: err.toString()});
  }
}

function updateData(payload) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEET_NAME);
    const idField = payload.idField || 'id sản phẩm'; 
    const idValue = payload.idValue;
    
    const values = sheet.getDataRange().getValues();
    const headers = values[0];
    const idColIndex = headers.indexOf(idField);
    
    if (idColIndex === -1) return jsonResponse({success: false, message: 'ID Field not found: ' + idField});
    
    for (let i = 1; i < values.length; i++) {
      if (String(values[i][idColIndex]).trim() === String(idValue).trim()) {
        const rowNum = i + 1;
        headers.forEach((header, index) => {
          if (header && payload.data[header] !== undefined) {
             sheet.getRange(rowNum, index + 1).setValue(payload.data[header]);
          }
        });
        return jsonResponse({success: true});
      }
    }
    
    return jsonResponse({success: false, message: 'Item not found for update'});
  } catch (err) {
    return jsonResponse({success: false, message: err.toString()});
  }
}

function deleteData(payload) {
  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(SHEET_NAME);
    
    if (!payload.data) {
      return jsonResponse({success: false, message: 'No data provided for delete operation'});
    }
    
    // Đọc headers để map dữ liệu
    const range = sheet.getDataRange();
    const values = range.getValues();
    const headers = values[0];
    
    // Tìm hoặc tạo cột "trạng thái xóa"
    let deleteColIndex = headers.findIndex(h => String(h).trim().toLowerCase() === 'trạng thái xóa');
    
    if (deleteColIndex === -1) {
        deleteColIndex = headers.length;
        sheet.getRange(1, deleteColIndex + 1).setValue('trạng thái xóa');
    }
    
    // Tạo dòng mới với toàn bộ data + trạng thái DELETED (Logic giữ nguyên là tạo DELETED record)
    const newRow = [];
    headers.forEach((h, index) => {
        if (index === deleteColIndex) {
            newRow.push('DELETED');
        } else if (payload.data[h] !== undefined) {
            newRow.push(payload.data[h]);
        } else {
            newRow.push('');
        }
    });
    
    // Nếu cột trạng thái xóa mới được thêm (nằm ngoài headers cũ)
    if (deleteColIndex >= headers.length) {
        newRow[deleteColIndex] = 'DELETED';
    }
    
    // NOTE: Với Pima có thể ta muốn update dòng cũ thành DELETED thay vì append dòng mới.
    // Tuy nhiên đề bài yêu cầu "như Duraflex" nên ta giữ nguyên logic Append DELETED row.
    // Logic của Duraflex là append row với status DELETED để frontend lọc ra.
    // Nhưng tối ưu hơn là tìm và update dòng cũ.
    // Nhưng OK, ta cứ theo chuẩn Duraflex file kia.
    sheet.appendRow(newRow);
    
    return jsonResponse({success: true, message: 'Created DELETED record in sheet'});
  } catch (err) {
    return jsonResponse({success: false, message: err.toString()});
  }
}

function uploadFile(payload) {
  try {
    const folder = DriveApp.getFolderById(payload.folderId);
    const blob = Utilities.newBlob(Utilities.base64Decode(payload.file), payload.mimeType, payload.filename);
    const file = folder.createFile(blob);
    file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    // Auto convert to direct link like Duraflex fix
    const url = 'https://lh3.googleusercontent.com/d/' + file.getId();
    return jsonResponse({success: true, url: url});
  } catch (err) {
    return jsonResponse({success: false, message: err.toString()});
  }
}

function jsonResponse(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}
